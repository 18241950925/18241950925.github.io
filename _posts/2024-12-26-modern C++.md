---
title: modern c++
date: 2024-12-26  # HH:MM:SS +/-TTTT
categories: [CS, c++]
tags: [学习笔记]     # TAG names should always be lowercase
description: 这是一篇根据Stanford CS106L 所完成的C++学习笔记
---

### 赋值
1. 直接赋值
2. 统一赋值
```
 std::vector<int> numbers{1, 2, 3, 4, 5};
 std::map<std::string, int> ages{ {"Alice", 25}, {"Bob", 30},{"Charlie", 35} };
student st1 {"Luish",29, true};
```
3. 结构化绑定
auto [className, buildingName, language] = getClassInfo();

## iteration
++it 返回的是引用，it++返回的是copy
### input iterators
可以求得迭代器内部的值 ` auto iter = *it`
### Output iterators
可以修改内部的值 ` *it = 3`
### foward iterator
满足Multipass
#### Multipass Guarantee
简单说，Multipass Guarantee不仅仅要求迭代器允许拷贝和在解引用后原位置仍有效，同时它还要求相同的两个迭代器，解引用后得到的对象应该是同一对象，进一步说，同一对象指的是相同地址
- 如果两个迭代器指向同一个范围的同一位置，它们的行为必须一致。
- 多次遍历相同的数据范围，迭代器的行为必须可重复。

```
it1 =it2
++ it1 == ++ it2
```
### Bidirictional iterators
可以++ 也可以--
#### random access iterator
可以 `auto a  = it +2`

![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-1.png)




## class
### class基础
      class B {
      public:
          B() : i_(0) {}
          virtual ~B() {}
          virtual void f(int i) = 0;
          int get() const { return i_; }
      protected:
          int i_;
      };


- public：对外部公开的接口和方法，允许用户直接调用。
- protected：希望继承类可以访问，但不希望外部访问的成员，比如一些实现细节或辅助方法。
- private：完全隐藏的内部数据和方法，不希望任何外部或继承类访问，通常用于保护数据和实现的细节。
=0 代表不在基类中实现
virtual 代表虚函数

## 模版
### 函数模版
例子：
        
    #include <iostream>
    using namespace std;
    template <typename T>
    T add(T a, T b) {
    	return a + b;
    }

    template <>  string add<string>(string a, string b)
    {
    	return string("string:") + a + b;
    }

    int main()
    {
    	std::cout << add(string("ad"), string("adawd"));
    	return 0;
    }
这里的加法就可以是浮点数，也可以是整数。如果想针对字符串类型做特殊处理，需要采用函数模版特化
### 模版特化
 上面的第二个函数就是模版特化的例子，前面的template<>代表全特化（函数没有偏特化），add后面的那个可以不加

### 默认值
    template <typename T1 = int, typename T2 = double>
    T1 add(T1 a, T2 b) {
        return a + b;
    }
如果实例不声明，那么会按照默认值处理

### 变长模版参数
    template <typename T>
    void print(T value) {
        cout << value << endl;
    }

    template <typename T, typename... Args>
    void print(T value, Args... args) {
        cout << value << " ";
        print(args...);  // 递归调用，展开参数包
    }

    int main() {
        print(1, 2.5, "hello", true);  // 打印多个不同类型的值
        return 0;
    }
这个例子使用了 Args... 作为一个变长模板参数包，允许 print 函数接受任意数量的参数并递归处理它们。
> 本质上是一种递归的处理。首先写出base版本，即可以终止递归的基础函数，然后在写一个调用它的递归函数，其中递归部分的参数是不确定的，采用可变参数表示。编译器在这个过程中会帮我们展开递归，并生成对应参数个数的重载函数![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-5.png)

### 类模版
    template <typename T>
    class Box {
    public:
        Box(T value) : value(value) {}
        T getValue() const { return value; }
    private:
        T value;
    };

    int main() {
        Box<int> intBox(10);           // T 被推导为 int
        Box<std::string> stringBox("Hello");  // T 被推导为 std::string
        return 0;
    }
### 模版特化
    template <typename T>
    class Box {
    public:
        Box(T value) : value(value) {}
        T getValue() const { return value; }
    private:
        T value;
    };

    // 特化版本
    template <>
    class Box<std::string> {
    public:
        Box(std::string value) : value(value) {}
        std::string getValue() const { return "String: " + value; }
    private:
        std::string value;
    };
### 模版的类型限制
因为一些函数模版，比如min函数，需要要求两个参数可以比较，因此引入concept来限制参数类型
#### concept
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-2.png)
为了应用这个约束，可以按照如下方式
```
template <Comparable T>
T min(const T& a,const T& b);
```
c++有一些内置的concept
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-3.png)

同样的，针对迭代器也有一些concept
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-4.png)

### 模版元编程
利用模版的类型推导来做一些将程序放到编译时执行的优化，比如通过模版计算斐波那契数列
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-7.png)
### constexp/consteval 
因为模版元编程可能语法不太美丽，可以采用这种方式提醒编译器，可以在编译时计算该常量表达式
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-8.png)


## functions
将函数作为参数的一部分传入模版，可以进一步实行泛型编程的概念。
比如find函数，如果只有一个type的模板，就没法指定寻找策略，但是传入一个所谓的谓词，即predicate，也就是一个bool的函数，就可以自定义这一点
c++里的find_if 就支持在后面传入一个类型为函数指针的参数。bool(*)(typename)
```
template <typename T,typename pred>
T find_if(T begin, T end,pred predicate)
{
    for(auto it = begin; it != end;++it)
    {
        if(predicate(*it))
        {
            return it;
        }
    }
    return end;
}
```
但是如上面代码所描述的那样，在调用这个谓词的时候，只能传入一个参数，这可能无法满足所有功能，比如传入函数的参数为多个时，这时引入lambda函数的概念

### lambda function
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-9.png)
1. 作用：主要是避免大量传参。比如一个函数里要调用另一个函数，但是有很多变量要传参，就可以不在外边定义一个新的函数，而是直接在这个函数里面定义一个lambda函数，可以自动获取外部变量，即caller函数中的变量
2. 形式： auto f\[捕获外围变量] (参数列表)-> 返回类型(可以为空){......}
![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image.png)
[&] 意思是自动所有的外部变量按照引用捕获，[=]意思是按照值捕获，即make a copy. [this]捕获当前实例的指针，[& x]是除了x都是引用
3. 扩展用途：可以将参数类型设置为auto，当做函数模版来用
[](auto a,auto b) {return a+b;}
参数中auto &&self代表这个函数可以递归调用自身

        auto dfs = [&](auto &&self, int idx) -> void {
                vis[idx] = 1;
                for (int i = 1; i <= n; i++)
                if (g[idx][i] && !vis[i])
                        self(self, i);
        };

### 仿函数
表现像函数的对象，这是通过重载()运算符来实现的，
例如

    struct my_functor
    {
        bool operator()(int a,int b){return a<b;}    
        private:
            int n;
    };
    my_functor f;
    bool a = f(1,2);

### lambda 函数的实质
本质上是一种语法糖，编译器会将他转换为仿函数，利用()调用函数，[]中捕获的变量实质上是仿函数的私有变量，通过对其实例化时传入

### range /c++20
这个是stl中的一个新特性，range库里的算法可以直接将容器作为参数

    std::vector<int> a{1,2,3,4,5,6,7,8,9,10,11}
    auto x = std::range::find(a,3);

该函数也可以接受迭代器作为参数，比如像限制搜索范围的时候。
并且range模版使用了concept，这代表了更好地报错信息

### view
view是一种对range的惰性处理，包含filter,tranform等操作，这些操作不会对原本的容器做修改抑或是生成新的对象，只是对现有range执行操作并返回操作后的视图。![alt text](https://github.com/18241950925/18241950925.github.io/raw/main/images/2024-12-26-modern%20C%2B%2B/image-10.png)
在前面的操作并不会发生什么，直到最后一步才会产生变化。
> | 操作符可以用来链接多个view操作。

## 运算符重载
#### 不能被重载的运算符
:: ? . .* sizeof()
typeid() cast()
#### 例子

    bool Student::operator<(const Student&other)
    {
        return id < other.id;
    }
### 两种重载模式
1. 成员式重载：在类的作用域内部声明重载
2. 非成员式重载：在类的定义外部声明，但是操作符的左值和右值都要加入到参数当中。(上面的例子是在类内定义的，因此参数只有右值)
    `bool operator<(const Student &lhs,const Student &rhs);`

> 其中第二种更符合c++，而且在stl中也基本是这种写法，因为这种写法允许左值是非类的类型。并且可以利用定义的其他类来重载这个运算符

### friend 关键字
friend 关键字允许非成员函数与类访问其他类的私有变量。
在目标类的头文件中，将操作符重载函数声明为好友函数
###### .h
class student
{
    private:
        int id;
    public:
        friend bool operator<(const student lhs&, const student rhs&);
}
###### .cpp

    bool operator< (const StudentID& lhs, const StudentID& rhs) {
        return lhs.id < rhs.id;
    }

> 对上面代码的一点解释：
> 1. 为什么需要friend，首先虽然这个运算符重载定义在类的里面，但是他是非成员函数式重载，并不是成员函数，因此需要friend才能访问private变量
> 2. 如果是成员函数式重载，只传一个参数，因为第一个参数默认是this
### 运算符重载的目的
经过上述的重载，现在可以对两个类进行比较了，最重要的是，运算符允许表达类型的含义，但是函数不能
#### ps

    operator bool() const {
        if (value != std::nullptr_t)
        return true;
        return false;
    }
可以用于用()判断指针是否为空的情况


## 特殊成员函数
### 6种特殊函数
class widget{
    public:
        widget(); //默认构造函数
        widget(const &widget w); // 复制构造函数 
        widget operator=(const &widget w); // 复制赋值构造函数
        ~widget(); // 析构函数
        widget (widget&& rhs); // 移动构造函数
        widget &operator=(widget&& rhs); // 移动赋值构造函数

}
- 复制构造函数：创建一个新对象，作为另一个对象的成员复制
  
        Widget widgetOne;
        Widget widgetTwo = widgetOne; // Copy constructor is called
- 复制赋值构造函数：将一个已存在的对象指定给另一个对象

        Widget widgetOne;
        Widget widgetTwo;
        widgetOne = widgetTwo
