# 算法
## 2
### D
dp[i][j] 表示第i个牛的喂粮食的操作次数， 需要再计算到dp[i][j]的第二维度的时候用到前缀和，以及在n为偶数的时候，只需要考虑一种情况，因为都是等价的。
## 3
### A
采用动态规划+贪心算法求解，在遇到2的时候，保留可能得最短的两种情况，一直到下一个2或者结束为止。由于相同会消除，因此最终的路径一定只能是010101这种结构，因此状态只需用长度与栈顶表示。维持2种状态是因为对于0210这种可能会约到头的路径来说，贪心算法不能得到最优解。下面是代码实现：

```python
import sys

def solve():
    # 使用快速IO读取所有输入
    input_data = sys.stdin.read().strip()
    if not input_data:
        return

    # 这里的输入可能包含换行符，我们只取第一行如果不含空格的话，或者直接处理字符串
    s = input_data.split()[0] if input_data else ""
    if not s:
        print(0)
        return

    # 状态定义: states[length] = mask
    # Mask 定义:
    # Bit 0 (1): 以 '0' 结尾
    # Bit 1 (2): 以 '1' 结尾
    # Bit 2 (4): 空栈
    
    # 初始状态: 长度0，掩码4 (Empty)
    states = {0: 4}

    # 预先定义常量以加速访问
    MASK_0 = 1      # stack ends with '0'
    MASK_1 = 2      # stack ends with '1'
    MASK_EMPTY = 4  # stack is empty

    for char in s:
        next_states = {}
        
        # 确定当前字符可能的取值
        # char '0' -> [0]
        # char '1' -> [1]
        # char '2' -> [0, 1]
        possible_vals = []
        if char == '0':
            possible_vals = [0]
        elif char == '1':
            possible_vals = [1]
        else: # char == '2'
            possible_vals = [0, 1]

        for val in possible_vals:
            for length, mask in states.items():
                
                # --- 情况 1: 当前是空栈 (检查 bit 2) ---
                if mask & MASK_EMPTY:
                    new_len = 1
                    # 如果进0，结尾变0(mask 1)；如果进1，结尾变1(mask 2)
                    # 刚好对应 (1 << val)
                    new_mask = (1 << val)
                    next_states[new_len] = next_states.get(new_len, 0) | new_mask

                # --- 情况 2: 当前栈顶是 '0' (检查 bit 0) ---
                if mask & MASK_0:
                    if val == 0: 
                        # '0' 碰 '0' -> 消除 (Pop)
                        new_len = length - 1
                        # 栈也是交替的 (...10)，消掉0后剩下1。如果消完长度为0则为空。
                        new_mask = MASK_EMPTY if new_len == 0 else MASK_1
                        next_states[new_len] = next_states.get(new_len, 0) | new_mask
                    else: 
                        # '1' 碰 '0' -> 入栈 (Push)
                        new_len = length + 1
                        new_mask = MASK_1
                        next_states[new_len] = next_states.get(new_len, 0) | new_mask

                # --- 情况 3: 当前栈顶是 '1' (检查 bit 1) ---
                if mask & MASK_1:
                    if val == 1:
                        # '1' 碰 '1' -> 消除 (Pop)
                        new_len = length - 1
                        # 栈是交替的 (...01)，消掉1后剩下0。如果消完长度为0则为空。
                        new_mask = MASK_EMPTY if new_len == 0 else MASK_0
                        next_states[new_len] = next_states.get(new_len, 0) | new_mask
                    else:
                        # '0' 碰 '1' -> 入栈 (Push)
                        new_len = length + 1
                        new_mask = MASK_0
                        next_states[new_len] = next_states.get(new_len, 0) | new_mask
        
        # --- 剪枝优化 (Pruning) ---
        if not next_states:
            # 理论上不会发生，除非输入非法导致无法转移
            states = {}
            break
            
        # 获取最小长度
        min_len = min(next_states.keys())
        
        # 只保留 min_len 和 min_len + 2
        # 原理：操作只会改变长度的奇偶性，且为了保留不同的栈顶可能性，只需保留次短路径
        pruned_states = {}
        pruned_states[min_len] = next_states[min_len]
        
        if (min_len + 2) in next_states:
            pruned_states[min_len + 2] = next_states[min_len + 2]
            
        states = pruned_states

    # 输出结果
    print(min(states.keys()))

if __name__ == "__main__":
    solve()
```

### B
贪心算法，每次都选择数量最多的石头会导致超时，因为需要模拟每一块石头。因此我们需要找到一个更快的算法。发现只要数量最多的石头数量不超过其余石头之和加一，就可以满足条件。需要考虑边界条件，即如果数量最大的恰好是边界的石头，且处在边界条件（等于其余石头加一），也会false，需要分类讨论，代码如下：

```python
def can_arrange(k, p, q, cnt):
    # Switch to 0-index for convenience.
    p -= 1
    q -= 1
    total = sum(cnt)

    # Case 1: endpoints are different.
    if p != q:
        cnt_p = cnt[p] - 1
        cnt_q = cnt[q] - 1
        if cnt_p < 0 or cnt_q < 0:
            return False
        cnt[p] = cnt_p
        cnt[q] = cnt_q

        # Remaining stones after fixing the endpoints.
        remaining = total - 2

        # If nothing remains, trivially valid.
        if remaining == 0:
            return True

        # If all remaining stones are a single color, that color must differ from both endpoints.
        max_color = 0
        max_idx = -1
        for i, c in enumerate(cnt):
            if c > max_color:
                max_color = c
                max_idx = i

        if max_color > (remaining + 1) // 2:
            return False
        if max_color == (remaining + 1) // 2 and max_color>remaining/2:
            if max_idx == p or max_idx == q:
                return False
        # # Edge safety: if every remaining stone is p or every remaining stone is q, the border would clash.
        # if cnt_p == remaining or cnt_q == remaining:
        #     return False
        return True

    # Case 2: endpoints are the same (color p == q).
    else:
        if cnt[p] < 2:
            return False
        cnt[p] -= 2  # consume two endpoints
        remaining = total - 2

        if remaining == 0:
            return False 

        # If all remaining stones are the same color, that color must differ from p.
        max_color = 0
        max_idx = -1
        for i, c in enumerate(cnt):
            if c > max_color:
                max_color = c
                max_idx = i
        # if max_color == remaining:
        #     return max_idx != p

        # Standard non-adjacent feasibility for a line of length `remaining`.
        if max_color > (remaining + 1) // 2:
            return False
        if cnt[p] >= (remaining + 1) // 2:
            return False
        return True


def main():
    k, p, q = map(int, input().split())
    cnt = list(map(int, input().split()))
    print(1 if can_arrange(k, p, q, cnt) else 0)


if __name__ == "__main__":
    main()
```

### C
首先将所有普通物品与鉴定后赚不到钱的物品卖了做本金，之后判断是否能买起卷轴，买得起就说明可以全部赚钱，否则只能把部分魔法物品直接卖掉。
至于卖哪些物品，用一个01背包问题的动态规划解决。（倒序遍历可以将二维压缩到一维）dp[j]表示赚到j的钱所需要的最少损失，最后用总钱数减去损失即为最终答案。代码如下：
```python
def main():
    n, p = map(int, input().split())
    money = 0
    magic = []
    for i in range(n):
        input_x = []
        input_x = list(map(int, input().split()))
        if len(input_x)==1:
            money += input_x[0]
        else:
            earn = input_x[1] - input_x[0] - p
            if earn <= 0:
                money+= input_x[0]
            else:
                magic.append([input_x[0], earn])
    magic.sort(key=lambda x: x[1], reverse=True)
    if money >= p:
        for x in magic:
            money = money+ x[0] + x[1]
        print(money)
    else:
        max_money= money
        for x in magic:
            max_money += x[0]
        if max_money < p:
            print(max_money)
            return
        else:
            need = p-money
            dp= [float('inf')]*(need+1)
            dp[0]=0
            all_earn = 0
            for item in magic:
                cost= item[0]
                earn= item[1]
                all_earn = all_earn + earn+cost
                for j in range(need, 0, -1):
                    if j - cost >= 0:
                        dp[j]= min(dp[j], dp[j-cost]+earn)
                    else:
                        if dp[0]+earn < dp[j]:
                            dp[j]= dp[0]+earn
            print(money + all_earn - dp[need])

if __name__ == "__main__":
    main()
```

### D
本题看似与排课问题类似，但是是环覆盖，衍生出来两个问题：1.如何将环断开成链 2.如何快速求解区间覆盖的最少区间数
首先，若不跨越边界，就添加这个区间，若跨越边界，就添加（r,l+n）
由于起始位置不固定，因此需要枚举所有可能的起始位置。之后在每一跳找到能到达最远的位置，直到覆盖到起始位置+n-1为止。这样的有个问题，可能需要跳许多次才能到终点，因此进行一次预处理，使用倍增思想预处理每个位置跳2^j次能到达的最远位置。这样每次查询从最坏的O(n)降到O(logn)。代码如下：
```python
def main():
    n, p = map(int, input().split())
    edge = []
    for i in range(p):
        l,r=map(int, input().split())
        edge.append((l,r))
        if r < l:
            edge.append((l,r+n))
        else:
            edge.append((l+n,r+n))
    edge.sort(key=lambda x: x[1])
    f = [[0] * (2*n+1) for _ in range(21)]
    nxt = [i for i in range(2 * n + 2)]

    # 2. 遍历边，只在起跑线标记最远终点
    for l, r in edge:
        # 这一步要根据题目断环成链的逻辑处理 l 和 r
        # 假设 l 和 r 已经处理好是链上的坐标
        # 比如：如果在位置 l-1 就能接到这个区间，那么 nxt[l-1] = r
        nxt[l - 1] = max(nxt[l - 1], r)

        # 3. 线性扫描，继承前面的最大值
    for i in range(1, 2 * n + 1):
        # 如果我能走到 i-1，那我肯定拥有 i-1 能跳到的最远距离
        # 这一步把“在这个位置能用哪些区间”的搜索过程变成了查表
        nxt[i] = max(nxt[i], nxt[i - 1])

    # 4. 赋值给倍增数组
    for i in range(1, 2 * n + 1):
        f[0][i] = nxt[i]

    for j in range(1,21):
        for i in range(1,2*n+1):
            f[j][i]=f[j-1][f[j-1][i]]
    res = 1e6+1
    for l,r in edge:
        if l>n:
            continue
        len = 1
        if r>=l+n:
            res=min(res,len)
            continue
        for j in range(20,-1,-1):
            if f[j][r]<l+n-1:
                len += 1<<j
                r=f[j][r]
        if f[0][r]>=l+n-1:
            res=min(res,len+1)
    if res < 1e6+1:
        print(res)
    else:
        print("impossible")


if __name__ == "__main__":
    main()
```

## 4